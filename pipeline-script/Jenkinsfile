pipeline {
    agent any

    environment {
        AWS_REGION = 'us-east-1'
        ECR_REPOSITORY = 'amazon-clone'
        IMAGE_NAME = 'amazon-clone'
        SONAR_PROJECT_KEY = 'amazon-clone'
        SONAR_SERVER_URL = 'http://3.81.44.159:9000'
        KUBERNETES_MANIFEST_REPO = 'https://github.com/Nalla06/k8s-manifests.git'
        KUBERNETES_MANIFEST_PATH = 'deployment.yml'
        EKS_CLUSTER_NAME = 'amazon-cluster'
        GIT_CREDENTIALS_ID = 'github-credentials'
        AWS_CREDENTIALS_ID = 'aws-ecr-credentials'
        DOCKERHUB_CREDENTIALS_ID = 'docker-hub-credentials'
        JAVA_HOME = '/usr/lib/jvm/java-17-openjdk-amd64'
    }

    stages {
        stage('Git Checkout') {
            steps {
                checkout scm
                sh 'git --version'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh '''
                    echo "Verifying Node.js and npm installation..."
                    node --version
                    npm --version
                '''
            }
        }

        stage('Code Quality Analysis') {
            environment {
                PATH = "${env.PATH}:/opt/sonar-scanner/bin"
                JAVA_HOME = '/usr/lib/jvm/java-17-openjdk-amd64'
                SONAR_TOKEN = credentials('sonarqube-token')
            }
            steps {
                script {
                    sh '''
                        if command -v sonar-scanner > /dev/null; then
                            echo "sonar-scanner found at $(which sonar-scanner)"
                            sonar-scanner --version
                        else
                            echo "sonar-scanner not found in PATH, please install it"
                            exit 1
                        fi
                    '''
                }
                withSonarQubeEnv('SonarQube') {
                    sh """
                        sonar-scanner -X \\
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \\
                            -Dsonar.sources=. \\
                            -Dsonar.host.url=${SONAR_SERVER_URL} \\
                            -Dsonar.login=${SONAR_TOKEN} \\
                            -Dsonar.tests=test \\
                            -Dsonar.exclusions=node_modules/**,test/**,**/*.test.js,**/*.spec.js
                    """
                }
            }
        }

        stage('Quality Gate') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    script {
                        def qualityGate = waitForQualityGate()
                        if (qualityGate.status != 'OK') {
                            error "Pipeline failed due to Quality Gate failure: ${qualityGate.status}"
                        } else {
                            echo "Quality Gate passed. Good job!"
                        }
                    }
                }
            }
        }

        stage('Build Application') {
            steps {
                sh 'npm run build || echo "Build warnings detected"'
            }
        }

        stage('Create ECR Repository') {
            steps {
                withAWS(credentials: AWS_CREDENTIALS_ID, region: AWS_REGION) {
                    script {
                        sh '''
                            if ! command -v aws &> /dev/null; then
                                echo "Installing AWS CLI..."
                                curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                unzip awscliv2.zip
                                sudo ./aws/install
                            fi
                        '''

                        def repoExists = sh(
                            script: "aws ecr describe-repositories --repository-names ${ECR_REPOSITORY} || true",
                            returnStatus: true
                        )

                        if (repoExists != 0) {
                            sh "aws ecr create-repository --repository-name ${ECR_REPOSITORY} --image-scanning-configuration scanOnPush=true"
                        }

                        env.ECR_URL = sh(script: "aws ecr describe-repositories --repository-names ${ECR_REPOSITORY} --query 'repositories[0].repositoryUri' --output text", returnStdout: true).trim()
                        env.ECR_REGISTRY = sh(script: "echo ${env.ECR_URL} | cut -d/ -f1", returnStdout: true).trim()
                        env.IMAGE_TAG = "${BUILD_NUMBER}"
                        env.FULL_IMAGE_NAME = "${env.ECR_URL}:${env.IMAGE_TAG}"
                    }
                }
            }
        }

        stage('Docker Build') {
            steps {
                script {
                    sh '''
                        if ! command -v docker &> /dev/null; then
                            echo "Installing Docker..."
                            sudo apt-get update
                            sudo apt-get install -y docker.io
                            sudo systemctl start docker
                            sudo systemctl enable docker
                        fi
                    '''
                    withCredentials([usernamePassword(credentialsId: DOCKERHUB_CREDENTIALS_ID, passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin || true'
                    }
                    sh "docker build -t ${FULL_IMAGE_NAME} ."
                }
            }
        }

        stage('Trivy Security Scan') {
            steps {
                sh '''
                    if ! command -v trivy &> /dev/null; then
                        echo "Installing Trivy..."
                        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
                    fi
                    trivy image --severity HIGH,CRITICAL --no-progress ${FULL_IMAGE_NAME} || echo "Trivy scan completed with issues"
                '''
            }
        }

        stage('Push to ECR') {
            steps {
                withAWS(credentials: AWS_CREDENTIALS_ID, region: AWS_REGION) {
                    sh '''
                        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        docker push ${FULL_IMAGE_NAME}
                        docker tag ${FULL_IMAGE_NAME} ${ECR_URL}:latest
                        docker push ${ECR_URL}:latest
                    '''
                }
            }
        }

        stage('Configure kubectl') {
            steps {
                withAWS(credentials: AWS_CREDENTIALS_ID, region: AWS_REGION) {
                    sh '''
                        if ! command -v kubectl &> /dev/null; then
                            echo "Installing kubectl..."
                            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                            chmod +x kubectl
                            sudo mv kubectl /usr/local/bin/
                        fi
                        aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}
                        kubectl get nodes
                    '''
                }
            }
        }

        stage('Clone K8s Manifest Repository') {
            steps {
                sh 'rm -rf k8s-manifests || true'
                withCredentials([usernamePassword(credentialsId: GIT_CREDENTIALS_ID, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                    sh "git clone https://${GIT_USERNAME}:${GIT_PASSWORD}@${KUBERNETES_MANIFEST_REPO.replace('https://', '')} k8s-manifests"
                }
            }
        }

        stage('Update Kubernetes Manifest') {
            steps {
                dir('k8s-manifests') {
                    script {
                        sh """
                            if [ ! -f "${KUBERNETES_MANIFEST_PATH}" ]; then
                                echo "Manifest not found!"
                                find . -name '*.yml' -o -name '*.yaml'
                                exit 1
                            fi

                            sed -i "s|image: .*${ECR_REPOSITORY}.*|image: ${FULL_IMAGE_NAME}|g" ${KUBERNETES_MANIFEST_PATH}

                            git config user.email 'lakshmi.rajyam06@gmail.com'
                            git config user.name 'Nalla06'
                            git add ${KUBERNETES_MANIFEST_PATH}
                            git commit -m "Update image to ${IMAGE_TAG} [ci skip]" || echo "No changes to commit"
                            git push https://${GIT_USERNAME}:${GIT_PASSWORD}@${KUBERNETES_MANIFEST_REPO.replace('https://', '')} HEAD:main
                        """
                    }
                }
            }
        }

        stage('Verify ArgoCD Sync Status') {
            steps {
                script {
                    sh '''
                        if ! command -v argocd &> /dev/null; then
                            echo "ArgoCD CLI not found. Please check the ArgoCD UI manually."
                        else
                            echo "ArgoCD CLI found. Add your app verification logic here."
                            # Example:
                            # argocd app wait amazon-clone --timeout 300
                        fi
                    '''
                }
            }
        }
    }

    post {
        success {
            echo "Pipeline executed successfully!"
        }

        failure {
            echo "Pipeline failed. Check logs for more details."
        }

        always {
            sh "docker rmi ${FULL_IMAGE_NAME} || true"
            sh "docker rmi ${ECR_URL}:latest || true"

            script {
                def recipient = 'your-team@example.com'
                def subject = "Pipeline Status: ${currentBuild.fullDisplayName}"
                def body = """
                Pipeline Status: ${currentBuild.result}
                Build URL: ${env.BUILD_URL}
                Image: ${FULL_IMAGE_NAME}
                ArgoCD should auto-sync the changes.
                """

                try {
                    emailext (
                        subject: subject,
                        body: body,
                        to: recipient
                    )
                } catch (e) {
                    echo "Email plugin not available or failed. Would have sent:"
                    echo "To: ${recipient}\nSubject: ${subject}\n${body}"
                }
            }
        }
    }
}